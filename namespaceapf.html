<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Audio Processing Framework (APF): apf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Audio Processing Framework (APF)
   &#160;<span id="projectnumber">version 0.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">apf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Audio Processing Framework.  
<a href="namespaceapf.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceapf_1_1conv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf_1_1conv.html">conv</a></td></tr>
<tr class="memdesc:namespaceapf_1_1conv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution engine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapf_1_1dp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf_1_1dp.html">dp</a></td></tr>
<tr class="memdesc:namespaceapf_1_1dp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denormal prevention. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapf_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespaceapf_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mathematical constants and helper functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapf_1_1mex"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf_1_1mex.html">mex</a></td></tr>
<tr class="memdesc:namespaceapf_1_1mex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for creating MEX files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceapf_1_1str"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf_1_1str.html">str</a></td></tr>
<tr class="memdesc:namespaceapf_1_1str"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for string manipulation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1accumulating__iterator.html">accumulating_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output iterator which adds on assignment.  <a href="classapf_1_1accumulating__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1BiQuad.html">BiQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct Form II recursive filter of second order.  <a href="classapf_1_1BiQuad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1BlockDelayLine.html">BlockDelayLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block-based delay line.  <a href="classapf_1_1BlockDelayLine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1BlockParameter.html">BlockParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hold current and old value of any type.  <a href="classapf_1_1BlockParameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Cascade.html">Cascade</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cascade of filter sections.  <a href="classapf_1_1Cascade.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1cast__iterator.html">cast_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator that casts items to <code>T*</code> on dereferenciation.  <a href="classapf_1_1cast__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1cast__proxy.html">cast_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate a container of base pointers.  <a href="structapf_1_1cast__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1cast__proxy__const.html">cast_proxy_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate a container of base pointers (const version).  <a href="structapf_1_1cast__proxy__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1circular__iterator.html">circular_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular iterator class.  <a href="classapf_1_1circular__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CombineChannels.html">CombineChannels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine channels: transform and accumulate.  <a href="classapf_1_1CombineChannels.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CombineChannelsBase.html">CombineChannelsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for CombineChannels*.  <a href="classapf_1_1CombineChannelsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CombineChannelsCopy.html">CombineChannelsCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine channels: accumulate.  <a href="classapf_1_1CombineChannelsCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CombineChannelsCrossfade.html">CombineChannelsCrossfade</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine channels: transform, crossfade and accumulate.  <a href="classapf_1_1CombineChannelsCrossfade.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CombineChannelsCrossfadeBase.html">CombineChannelsCrossfadeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for CombineChannelsCrossfade*.  <a href="classapf_1_1CombineChannelsCrossfadeBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CombineChannelsCrossfadeCopy.html">CombineChannelsCrossfadeCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine channels: crossfade and accumulate.  <a href="classapf_1_1CombineChannelsCrossfadeCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CombineChannelsInterpolation.html">CombineChannelsInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine channels: interpolate and accumulate.  <a href="classapf_1_1CombineChannelsInterpolation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CommandQueue.html">CommandQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage command queue from non-realtime thread to realtime thread.  <a href="classapf_1_1CommandQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CRTP.html">CRTP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curiously Recurring Template Pattern (<a class="el" href="classapf_1_1CRTP.html" title="Curiously Recurring Template Pattern (CRTP) base class.">CRTP</a>) base class.  <a href="classapf_1_1CRTP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1discard__iterator.html">discard_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator which does nothing.  <a href="classapf_1_1discard__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1dual__iterator.html">dual_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over two iterators at once.  <a href="classapf_1_1dual__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1fftw.html">fftw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class to select float/double/long double versions of FFTW functions.  <a href="structapf_1_1fftw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1fftw_3_01double_01_4.html">fftw&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> double </b> specialization of the traits class <a class="el" href="structapf_1_1fftw.html">fftw</a>  <a href="structapf_1_1fftw_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1fftw_3_01float_01_4.html">fftw&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> float </b> specialization of the traits class <a class="el" href="structapf_1_1fftw.html">fftw</a>  <a href="structapf_1_1fftw_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1fftw_3_01long_01double_01_4.html">fftw&lt; long double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> long double </b> specialization of the traits class <a class="el" href="structapf_1_1fftw.html">fftw</a>  <a href="structapf_1_1fftw_3_01long_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1fftw__allocator.html">fftw_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1fixed__list.html">fixed_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived from std::list, but without re-sizing.  <a href="classapf_1_1fixed__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1fixed__matrix.html">fixed_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-dimensional data storage for row- and column-wise access.  <a href="classapf_1_1fixed__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1fixed__vector.html">fixed_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived from <code>std::vector</code>, but without memory re-allocations.  <a href="classapf_1_1fixed__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1has__begin__and__end.html">has_begin_and_end</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class providing <a class="el" href="classapf_1_1has__begin__and__end.html#a58767dcbdff1b34a40fa9ca0bef88359" title="Get begin.">begin()</a> and <a class="el" href="classapf_1_1has__begin__and__end.html#a481f29e71635cf658e3d2a3eb78143c3" title="Get end.">end()</a>.  <a href="classapf_1_1has__begin__and__end.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1index__iterator.html">index_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator with a built-in number.  <a href="classapf_1_1index__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1iterator__proxy.html">iterator_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for <a class="el" href="structapf_1_1cast__proxy.html" title="Encapsulate a container of base pointers.">apf::cast_proxy</a> and <a class="el" href="structapf_1_1transform__proxy.html" title="Wrap a container and provide a transform_iterator instead of the normal one.">apf::transform_proxy</a>.  <a href="classapf_1_1iterator__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1iterator__proxy__const.html">iterator_proxy_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for <a class="el" href="structapf_1_1cast__proxy__const.html" title="Encapsulate a container of base pointers (const version).">cast_proxy_const</a> and <a class="el" href="structapf_1_1transform__proxy__const.html" title="Wrap a container and provide a transform_iterator (const version).">transform_proxy_const</a>.  <a href="classapf_1_1iterator__proxy__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1jack__policy.html">jack_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>interface_policy</code> using JACK.  <a href="classapf_1_1jack__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1JackClient.html">JackClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ wrapper for a JACK client.  <a href="classapf_1_1JackClient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1LaplaceCoefficients.html">LaplaceCoefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of analog recursive filter.  <a href="structapf_1_1LaplaceCoefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1LockFreeFifo_3_01T_01_5_01_4.html">LockFreeFifo&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free first-in-first-out (FIFO) queue.  <a href="classapf_1_1LockFreeFifo_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1MimoProcessor.html">MimoProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded multiple-input-multiple-output (MIMO) processor.  <a href="classapf_1_1MimoProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1NonCausalBlockDelayLine.html">NonCausalBlockDelayLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-based delay line where negative delay is possible.  <a href="classapf_1_1NonCausalBlockDelayLine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1NonCopyable.html">NonCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes derived from this class cannot be copied (but still moved).  <a href="classapf_1_1NonCopyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1parameter__map.html">parameter_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "dictionary" for parameters.  <a href="structapf_1_1parameter__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1pointer__policy_3_01T_01_5_01_4.html">pointer_policy&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>interface_policy</code> which uses plain pointers.  <a href="classapf_1_1pointer__policy_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1portaudio__policy.html">portaudio_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>interface_policy</code> using PortAudio.  <a href="classapf_1_1portaudio__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1raised__cosine__fade.html">raised_cosine_fade</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crossfade using a raised cosine.  <a href="classapf_1_1raised__cosine__fade.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1RtList_3_01T_01_5_01_4.html">RtList&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list for realtime access and non-realtime modification.  <a href="classapf_1_1RtList_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1SosCoefficients.html">SosCoefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of digital recursive filter (second order section).  <a href="structapf_1_1SosCoefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1StopWatch.html">StopWatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple stopwatch.  <a href="classapf_1_1StopWatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1stride__iterator.html">stride_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stride iterator.  <a href="classapf_1_1stride__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1transform__iterator.html">transform_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator adaptor with a function call at dereferenciation.  <a href="classapf_1_1transform__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1transform__proxy.html">transform_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a container and provide a <a class="el" href="classapf_1_1transform__iterator.html" title="Iterator adaptor with a function call at dereferenciation.">transform_iterator</a> instead of the normal one.  <a href="structapf_1_1transform__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1transform__proxy__const.html">transform_proxy_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a container and provide a <a class="el" href="classapf_1_1transform__iterator.html" title="Iterator adaptor with a function call at dereferenciation.">transform_iterator</a> (const version).  <a href="structapf_1_1transform__proxy__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a773ecea426d4e63c45a1ea9e4004e4ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a773ecea426d4e63c45a1ea9e4004e4ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a773ecea426d4e63c45a1ea9e4004e4ab">no_nullptr</a> (T *in)</td></tr>
<tr class="memdesc:a773ecea426d4e63c45a1ea9e4004e4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for null-pointer.  <a href="namespaceapf.html#a773ecea426d4e63c45a1ea9e4004e4ab">More...</a><br /></td></tr>
<tr class="separator:a773ecea426d4e63c45a1ea9e4004e4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947d60e47dc73b17093454e7da1be4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7947d60e47dc73b17093454e7da1be4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7947d60e47dc73b17093454e7da1be4b">no_nullptr</a> (T &amp;)</td></tr>
<tr class="memdesc:a7947d60e47dc73b17093454e7da1be4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy overload for non-pointers.  <a href="namespaceapf.html#a7947d60e47dc73b17093454e7da1be4b">More...</a><br /></td></tr>
<tr class="separator:a7947d60e47dc73b17093454e7da1be4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da4b0aeb4e58e40a6e95bd9f5196bcc"><td class="memTemplParams" colspan="2"><a id="a6da4b0aeb4e58e40a6e95bd9f5196bcc"></a>
template&lt;typename I , typename... Args&gt; </td></tr>
<tr class="memitem:a6da4b0aeb4e58e40a6e95bd9f5196bcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1has__begin__and__end.html">has_begin_and_end</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_begin_and_end</b> (I first, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a6da4b0aeb4e58e40a6e95bd9f5196bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c89934412d27d4f2e24fcde134b94f1"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ga6c89934412d27d4f2e24fcde134b94f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1accumulating__iterator.html">accumulating_iterator</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__apf__iterators.html#ga6c89934412d27d4f2e24fcde134b94f1">make_accumulating_iterator</a> (I base_iterator)</td></tr>
<tr class="memdesc:ga6c89934412d27d4f2e24fcde134b94f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create an <a class="el" href="classapf_1_1accumulating__iterator.html" title="An output iterator which adds on assignment.">accumulating_iterator</a>.  <a href="group__apf__iterators.html#ga6c89934412d27d4f2e24fcde134b94f1">More...</a><br /></td></tr>
<tr class="separator:ga6c89934412d27d4f2e24fcde134b94f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529fada8ca064b44df0b221ba2c356cb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:ga529fada8ca064b44df0b221ba2c356cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1cast__iterator.html">cast_iterator</a>&lt; T, I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__apf__iterators.html#ga529fada8ca064b44df0b221ba2c356cb">make_cast_iterator</a> (I base_iterator)</td></tr>
<tr class="memdesc:ga529fada8ca064b44df0b221ba2c356cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="classapf_1_1cast__iterator.html" title="Iterator that casts items to T* on dereferenciation.">cast_iterator</a>.  <a href="group__apf__iterators.html#ga529fada8ca064b44df0b221ba2c356cb">More...</a><br /></td></tr>
<tr class="separator:ga529fada8ca064b44df0b221ba2c356cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaaec304282245da2f4ba137477c1b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:aecaaec304282245da2f4ba137477c1b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structapf_1_1cast__proxy.html">cast_proxy</a>&lt; T, Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aecaaec304282245da2f4ba137477c1b2">make_cast_proxy</a> (Container &amp;l)</td></tr>
<tr class="memdesc:aecaaec304282245da2f4ba137477c1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="structapf_1_1cast__proxy.html" title="Encapsulate a container of base pointers.">cast_proxy</a>.  <a href="namespaceapf.html#aecaaec304282245da2f4ba137477c1b2">More...</a><br /></td></tr>
<tr class="separator:aecaaec304282245da2f4ba137477c1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac941895f111060a9cd435f1fde847b57"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:ac941895f111060a9cd435f1fde847b57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structapf_1_1cast__proxy__const.html">cast_proxy_const</a>&lt; T, Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac941895f111060a9cd435f1fde847b57">make_cast_proxy_const</a> (Container &amp;l)</td></tr>
<tr class="memdesc:ac941895f111060a9cd435f1fde847b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="structapf_1_1cast__proxy__const.html" title="Encapsulate a container of base pointers (const version).">cast_proxy_const</a>.  <a href="namespaceapf.html#ac941895f111060a9cd435f1fde847b57">More...</a><br /></td></tr>
<tr class="separator:ac941895f111060a9cd435f1fde847b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cabb988665e9db9c4899b1b50792e80"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ga4cabb988665e9db9c4899b1b50792e80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1circular__iterator.html">circular_iterator</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__apf__iterators.html#ga4cabb988665e9db9c4899b1b50792e80">make_circular_iterator</a> (I begin, I end)</td></tr>
<tr class="memdesc:ga4cabb988665e9db9c4899b1b50792e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="classapf_1_1circular__iterator.html" title="Circular iterator class.">circular_iterator</a>.  <a href="group__apf__iterators.html#ga4cabb988665e9db9c4899b1b50792e80">More...</a><br /></td></tr>
<tr class="separator:ga4cabb988665e9db9c4899b1b50792e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa264c60286f543298548419ee35d82fe"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gaa264c60286f543298548419ee35d82fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1circular__iterator.html">circular_iterator</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__apf__iterators.html#gaa264c60286f543298548419ee35d82fe">make_circular_iterator</a> (I begin, I end, I current)</td></tr>
<tr class="memdesc:gaa264c60286f543298548419ee35d82fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="classapf_1_1circular__iterator.html" title="Circular iterator class.">circular_iterator</a>.  <a href="group__apf__iterators.html#gaa264c60286f543298548419ee35d82fe">More...</a><br /></td></tr>
<tr class="separator:gaa264c60286f543298548419ee35d82fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7880283a7f771a6d596ad82e47026717"><td class="memTemplParams" colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:ga7880283a7f771a6d596ad82e47026717"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1transform__iterator.html">transform_iterator</a>&lt; I, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__apf__iterators.html#ga7880283a7f771a6d596ad82e47026717">make_transform_iterator</a> (I base_iterator, F f)</td></tr>
<tr class="memdesc:ga7880283a7f771a6d596ad82e47026717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="classapf_1_1transform__iterator.html" title="Iterator adaptor with a function call at dereferenciation.">transform_iterator</a>.  <a href="group__apf__iterators.html#ga7880283a7f771a6d596ad82e47026717">More...</a><br /></td></tr>
<tr class="separator:ga7880283a7f771a6d596ad82e47026717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c89f827309cda1194a3da60ebf9586"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad6c89f827309cda1194a3da60ebf9586"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1index__iterator.html">index_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__apf__iterators.html#gad6c89f827309cda1194a3da60ebf9586">make_index_iterator</a> (T start)</td></tr>
<tr class="memdesc:gad6c89f827309cda1194a3da60ebf9586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create an <a class="el" href="classapf_1_1index__iterator.html" title="Iterator with a built-in number.">index_iterator</a>.  <a href="group__apf__iterators.html#gad6c89f827309cda1194a3da60ebf9586">More...</a><br /></td></tr>
<tr class="separator:gad6c89f827309cda1194a3da60ebf9586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd6e4cf799c232b710cb52b034463f6"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga3cd6e4cf799c232b710cb52b034463f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1dual__iterator.html">dual_iterator</a>&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__apf__iterators.html#ga3cd6e4cf799c232b710cb52b034463f6">make_dual_iterator</a> (I1 i1, I2 i2)</td></tr>
<tr class="memdesc:ga3cd6e4cf799c232b710cb52b034463f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create an <a class="el" href="classapf_1_1dual__iterator.html" title="Iterate over two iterators at once.">dual_iterator</a>.  <a href="group__apf__iterators.html#ga3cd6e4cf799c232b710cb52b034463f6">More...</a><br /></td></tr>
<tr class="separator:ga3cd6e4cf799c232b710cb52b034463f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b07b1bb01b6d0171f8190a31a5987c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78b07b1bb01b6d0171f8190a31a5987c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structapf_1_1SosCoefficients.html">SosCoefficients</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a78b07b1bb01b6d0171f8190a31a5987c">bilinear</a> (<a class="el" href="structapf_1_1LaplaceCoefficients.html">LaplaceCoefficients</a>&lt; T &gt; coeffs_in, int fs, int fp)</td></tr>
<tr class="memdesc:a78b07b1bb01b6d0171f8190a31a5987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bilinear transform.  <a href="namespaceapf.html#a78b07b1bb01b6d0171f8190a31a5987c">More...</a><br /></td></tr>
<tr class="separator:a78b07b1bb01b6d0171f8190a31a5987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927618fb7681e0458aefc2f1305880c9"><td class="memTemplParams" colspan="2">template&lt;typename L1 , typename L2 &gt; </td></tr>
<tr class="memitem:a927618fb7681e0458aefc2f1305880c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a927618fb7681e0458aefc2f1305880c9">append_pointers</a> (L1 &amp;source, L2 &amp;target)</td></tr>
<tr class="memdesc:a927618fb7681e0458aefc2f1305880c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append pointers to the elements of the first list to the second list.  <a href="namespaceapf.html#a927618fb7681e0458aefc2f1305880c9">More...</a><br /></td></tr>
<tr class="separator:a927618fb7681e0458aefc2f1305880c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ebf6995a896e813f120fb7dc1273f3"><td class="memTemplParams" colspan="2">template&lt;typename L1 , typename L2 &gt; </td></tr>
<tr class="memitem:a35ebf6995a896e813f120fb7dc1273f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a35ebf6995a896e813f120fb7dc1273f3">append_pointers</a> (const L1 &amp;source, L2 &amp;target)</td></tr>
<tr class="memdesc:a35ebf6995a896e813f120fb7dc1273f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const-version of <a class="el" href="namespaceapf.html#a927618fb7681e0458aefc2f1305880c9" title="Append pointers to the elements of the first list to the second list.">append_pointers()</a>  <a href="namespaceapf.html#a35ebf6995a896e813f120fb7dc1273f3">More...</a><br /></td></tr>
<tr class="separator:a35ebf6995a896e813f120fb7dc1273f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa6bafe6b8e46a52e739809c2328e47"><td class="memTemplParams" colspan="2">template&lt;typename L1 , typename L2 , typename DataMember &gt; </td></tr>
<tr class="memitem:a6aa6bafe6b8e46a52e739809c2328e47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a6aa6bafe6b8e46a52e739809c2328e47">distribute_list</a> (L1 &amp;source, L2 &amp;target, DataMember member)</td></tr>
<tr class="memdesc:a6aa6bafe6b8e46a52e739809c2328e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splice list elements from <code>source</code> to member lists of <code>target</code>.  <a href="namespaceapf.html#a6aa6bafe6b8e46a52e739809c2328e47">More...</a><br /></td></tr>
<tr class="separator:a6aa6bafe6b8e46a52e739809c2328e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7509310289e1f3815d2ccddc085e3fdc"><td class="memTemplParams" colspan="2">template&lt;typename L1 , typename L2 , typename DataMember , typename L3 &gt; </td></tr>
<tr class="memitem:a7509310289e1f3815d2ccddc085e3fdc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7509310289e1f3815d2ccddc085e3fdc">undistribute_list</a> (const L1 &amp;source, L2 &amp;target, DataMember member, L3 &amp;garbage)</td></tr>
<tr class="memdesc:a7509310289e1f3815d2ccddc085e3fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opposite of <a class="el" href="namespaceapf.html#a6aa6bafe6b8e46a52e739809c2328e47" title="Splice list elements from source to member lists of target.">distribute_list()</a> &ndash; sorry for the strange name!  <a href="namespaceapf.html#a7509310289e1f3815d2ccddc085e3fdc">More...</a><br /></td></tr>
<tr class="separator:a7509310289e1f3815d2ccddc085e3fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb316c28fb7a641220e9f060f31c9ea"><td class="memTemplParams" colspan="2">template&lt;typename Processor &gt; </td></tr>
<tr class="memitem:aabb316c28fb7a641220e9f060f31c9ea"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aabb316c28fb7a641220e9f060f31c9ea">mimoprocessor_file_io</a> (Processor &amp;processor, const std::string &amp;infilename, const std::string &amp;outfilename)</td></tr>
<tr class="memdesc:aabb316c28fb7a641220e9f060f31c9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use MimoProcessor-based object with multichannel audio file input and output.  <a href="namespaceapf.html#aabb316c28fb7a641220e9f060f31c9ea">More...</a><br /></td></tr>
<tr class="separator:aabb316c28fb7a641220e9f060f31c9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fb0c05192b5883e63251ae34686773"><td class="memItemLeft" align="right" valign="top">SndfileHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a85fb0c05192b5883e63251ae34686773">load_sndfile</a> (const std::string &amp;name, size_t sample_rate, size_t channels)</td></tr>
<tr class="memdesc:a85fb0c05192b5883e63251ae34686773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load sound file, throw exception if something's wrong.  <a href="namespaceapf.html#a85fb0c05192b5883e63251ae34686773">More...</a><br /></td></tr>
<tr class="separator:a85fb0c05192b5883e63251ae34686773"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Audio Processing Framework. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a773ecea426d4e63c45a1ea9e4004e4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773ecea426d4e63c45a1ea9e4004e4ab">&#9670;&nbsp;</a></span>no_nullptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool apf::no_nullptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for null-pointer. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <code>in</code> != 0, else <b>false</b> </dd></dl>

<p class="definition">Definition at line <a class="el" href="iterator_8h_source.html#l00064">64</a> of file <a class="el" href="iterator_8h_source.html">iterator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="iterator_8h_source.html#l00536">apf::cast_iterator&lt; T, I &gt;::cast_iterator()</a>, <a class="el" href="iterator_8h_source.html#l00695">apf::circular_iterator&lt; typename Container::iterator &gt;::circular_iterator()</a>, <a class="el" href="iterator_8h_source.html#l00477">apf::accumulating_iterator&lt; I &gt;::operator*()</a>, <a class="el" href="iterator_8h_source.html#l01235">apf::dual_iterator&lt; I1, I2 &gt;::operator*()</a>, <a class="el" href="container_8h_source.html#l00466">apf::fixed_matrix&lt; T, Allocator &gt;::channels_iterator::operator*()</a>, <a class="el" href="container_8h_source.html#l00540">apf::fixed_matrix&lt; T, Allocator &gt;::slices_iterator::operator*()</a>, <a class="el" href="iterator_8h_source.html#l00750">apf::circular_iterator&lt; typename Container::iterator &gt;::operator++()</a>, <a class="el" href="iterator_8h_source.html#l01101">apf::stride_iterator&lt; channel_iterator &gt;::operator++()</a>, <a class="el" href="iterator_8h_source.html#l01244">apf::dual_iterator&lt; I1, I2 &gt;::operator++()</a>, <a class="el" href="iterator_8h_source.html#l00770">apf::circular_iterator&lt; typename Container::iterator &gt;::operator+=()</a>, <a class="el" href="iterator_8h_source.html#l01124">apf::stride_iterator&lt; channel_iterator &gt;::operator+=()</a>, <a class="el" href="iterator_8h_source.html#l00760">apf::circular_iterator&lt; typename Container::iterator &gt;::operator--()</a>, <a class="el" href="iterator_8h_source.html#l01109">apf::stride_iterator&lt; channel_iterator &gt;::operator--()</a>, <a class="el" href="iterator_8h_source.html#l00550">apf::cast_iterator&lt; T, I &gt;::operator-&gt;()</a>, <a class="el" href="iterator_8h_source.html#l00560">apf::cast_iterator&lt; T, I &gt;::operator[]()</a>, and <a class="el" href="iterator_8h_source.html#l01117">apf::stride_iterator&lt; channel_iterator &gt;::operator[]()</a>.</p>

</div>
</div>
<a id="a7947d60e47dc73b17093454e7da1be4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947d60e47dc73b17093454e7da1be4b">&#9670;&nbsp;</a></span>no_nullptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool apf::no_nullptr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dummy overload for non-pointers. </p>
<dl class="section return"><dt>Returns</dt><dd>Always <b>true</b> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We can only check if plain pointers are NULL, use <code>_GLIBCXX_DEBUG</code> to check for singular iterators! </dd></dl>

<p class="definition">Definition at line <a class="el" href="iterator_8h_source.html#l00070">70</a> of file <a class="el" href="iterator_8h_source.html">iterator.h</a>.</p>

</div>
</div>
<a id="aecaaec304282245da2f4ba137477c1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecaaec304282245da2f4ba137477c1b2">&#9670;&nbsp;</a></span>make_cast_proxy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapf_1_1cast__proxy.html">cast_proxy</a>&lt;T, Container&gt; apf::make_cast_proxy </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create a <a class="el" href="structapf_1_1cast__proxy.html" title="Encapsulate a container of base pointers.">cast_proxy</a>. </p>

<p class="definition">Definition at line <a class="el" href="iterator_8h_source.html#l00632">632</a> of file <a class="el" href="iterator_8h_source.html">iterator.h</a>.</p>

</div>
</div>
<a id="ac941895f111060a9cd435f1fde847b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac941895f111060a9cd435f1fde847b57">&#9670;&nbsp;</a></span>make_cast_proxy_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapf_1_1cast__proxy__const.html">cast_proxy_const</a>&lt;T, Container&gt; apf::make_cast_proxy_const </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create a <a class="el" href="structapf_1_1cast__proxy__const.html" title="Encapsulate a container of base pointers (const version).">cast_proxy_const</a>. </p>

<p class="definition">Definition at line <a class="el" href="iterator_8h_source.html#l00657">657</a> of file <a class="el" href="iterator_8h_source.html">iterator.h</a>.</p>

</div>
</div>
<a id="a78b07b1bb01b6d0171f8190a31a5987c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b07b1bb01b6d0171f8190a31a5987c">&#9670;&nbsp;</a></span>bilinear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapf_1_1SosCoefficients.html">SosCoefficients</a>&lt;T&gt; apf::bilinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapf_1_1LaplaceCoefficients.html">LaplaceCoefficients</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>coeffs_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bilinear transform. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>internal data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs_in</td><td>coefficients of filter design in Laplace domain </td></tr>
    <tr><td class="paramname">fs</td><td>sampling rate </td></tr>
    <tr><td class="paramname">fp</td><td>prewarping frequency </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>coefficients in z-domain </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classapf_1_1BiQuad.html" title="Direct Form II recursive filter of second order.">BiQuad</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="biquad_8h_source.html#l00289">289</a> of file <a class="el" href="biquad_8h_source.html">biquad.h</a>.</p>

</div>
</div>
<a id="a927618fb7681e0458aefc2f1305880c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927618fb7681e0458aefc2f1305880c9">&#9670;&nbsp;</a></span>append_pointers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L1 , typename L2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apf::append_pointers </td>
          <td>(</td>
          <td class="paramtype">L1 &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L2 &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append pointers to the elements of the first list to the second list. </p>
<dl class="section note"><dt>Note</dt><dd><code>L2::value_type</code> must be a pointer to <code>L1::value_type!</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="container_8h_source.html#l00610">610</a> of file <a class="el" href="container_8h_source.html">container.h</a>.</p>

</div>
</div>
<a id="a35ebf6995a896e813f120fb7dc1273f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ebf6995a896e813f120fb7dc1273f3">&#9670;&nbsp;</a></span>append_pointers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L1 , typename L2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apf::append_pointers </td>
          <td>(</td>
          <td class="paramtype">const L1 &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L2 &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const-version of <a class="el" href="namespaceapf.html#a927618fb7681e0458aefc2f1305880c9" title="Append pointers to the elements of the first list to the second list.">append_pointers()</a> </p>
<dl class="section note"><dt>Note</dt><dd><code>L2::value_type</code> must be a pointer to <b>const</b> <code>L1::value_type!</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="container_8h_source.html#l00621">621</a> of file <a class="el" href="container_8h_source.html">container.h</a>.</p>

</div>
</div>
<a id="a6aa6bafe6b8e46a52e739809c2328e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa6bafe6b8e46a52e739809c2328e47">&#9670;&nbsp;</a></span>distribute_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L1 , typename L2 , typename DataMember &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apf::distribute_list </td>
          <td>(</td>
          <td class="paramtype">L1 &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L2 &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataMember&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splice list elements from <code>source</code> to member lists of <code>target</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Elements of this list are distributed to the corresponding <code>member</code> lists of <code>target</code>. This must have the same type as <code>member</code>. </td></tr>
    <tr><td class="paramname">target</td><td>Each element of this list receives one element of <code>source</code>. </td></tr>
    <tr><td class="paramname">member</td><td>The distributed elements are appended at <code>member.end()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Lists must have the same size. If not, an exception is thrown. </dd>
<dd>
There is no const version, both lists are modified. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>source</code> will be empty. </dd>
<dd>
The <code>member</code> of each <code>target</code> element will have one more element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="container_8h_source.html#l00639">639</a> of file <a class="el" href="container_8h_source.html">container.h</a>.</p>

</div>
</div>
<a id="a7509310289e1f3815d2ccddc085e3fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7509310289e1f3815d2ccddc085e3fdc">&#9670;&nbsp;</a></span>undistribute_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L1 , typename L2 , typename DataMember , typename L3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apf::undistribute_list </td>
          <td>(</td>
          <td class="paramtype">const L1 &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L2 &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataMember&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L3 &amp;&#160;</td>
          <td class="paramname"><em>garbage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The opposite of <a class="el" href="namespaceapf.html#a6aa6bafe6b8e46a52e739809c2328e47" title="Splice list elements from source to member lists of target.">distribute_list()</a> &ndash; sorry for the strange name! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Container of items which will be removed from <code>member</code> of the corresponding <code>target</code> elements. </td></tr>
    <tr><td class="paramname">target</td><td>Container of elements which have a <code>member</code>. </td></tr>
    <tr><td class="paramname">member</td><td>Member container from which elements will be removed. Must have a splice() member function (like <code>std::list</code>). </td></tr>
    <tr><td class="paramname">garbage</td><td>Removed elements are appended to this list. Must have the same type as <code>member</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If any element isn't found in the corresponding <code>member</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>If a list element is not found, an exception is thrown and the original state is <b>not</b> restored! </dd></dl>

<p class="definition">Definition at line <a class="el" href="container_8h_source.html#l00669">669</a> of file <a class="el" href="container_8h_source.html">container.h</a>.</p>

</div>
</div>
<a id="aabb316c28fb7a641220e9f060f31c9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb316c28fb7a641220e9f060f31c9ea">&#9670;&nbsp;</a></span>mimoprocessor_file_io()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Processor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int apf::mimoprocessor_file_io </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>infilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use MimoProcessor-based object with multichannel audio file input and output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">processor</td><td>Object derived from <a class="el" href="classapf_1_1MimoProcessor.html" title="Multi-threaded multiple-input-multiple-output (MIMO) processor.">MimoProcessor</a> </td></tr>
    <tr><td class="paramname">infilename</td><td>Input audio file name </td></tr>
    <tr><td class="paramname">outfilename</td><td>Output audio file name (will be overwritten if it exists) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="audiofile_simpleprocessor_8cpp-example.html#a2">audiofile_simpleprocessor.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mimoprocessor__file__io_8h_source.html#l00044">44</a> of file <a class="el" href="mimoprocessor__file__io_8h_source.html">mimoprocessor_file_io.h</a>.</p>

<p class="reference">References <a class="el" href="container_8h_source.html#l00413">apf::fixed_matrix&lt; T, Allocator &gt;::get_channel_ptrs()</a>, <a class="el" href="container_8h_source.html#l00589">apf::fixed_matrix&lt; T, Allocator &gt;::set_channels()</a>, and <a class="el" href="container_8h_source.html#l00418">apf::fixed_matrix&lt; T, Allocator &gt;::slices</a>.</p>

</div>
</div>
<a id="a85fb0c05192b5883e63251ae34686773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fb0c05192b5883e63251ae34686773">&#9670;&nbsp;</a></span>load_sndfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SndfileHandle apf::load_sndfile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sample_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load sound file, throw exception if something's wrong. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>file name </td></tr>
    <tr><td class="paramname">sample_rate</td><td>expected sample rate </td></tr>
    <tr><td class="paramname">channels</td><td>expected number of channels </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>whenever something is wrong </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sndfiletools_8h_source.html#l00046">46</a> of file <a class="el" href="sndfiletools_8h_source.html">sndfiletools.h</a>.</p>

<p class="reference">References <a class="el" href="stringtools_8h_source.html#l00052">apf::str::A2S()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
